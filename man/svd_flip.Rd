% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/util.R
\name{svd_flip}
\alias{svd_flip}
\title{Adjust signs of singular vectors from an SVD decomposition}
\usage{
svd_flip(u, v, u_based_decision = TRUE)
}
\arguments{
\item{u}{Numeric matrix representing the \( U \) matrix from an SVD decomposition.}

\item{v}{Numeric matrix representing the \( V \) matrix from an SVD decomposition.}

\item{u_based_decision}{Logical scalar indicating if the decision to adjust signs should be
based on \( U \) matrix. If `TRUE`, signs are adjusted based on the columns of \( U \);
if `FALSE`, the adjustment is based on the rows of \( V \).}
}
\value{
A list containing the adjusted \( U \) and \( V \) matrices.
}
\description{
This function adjusts the signs of the singular vectors \( U \) and \( V \) matrices from an
SVD decomposition to ensure consistent sign orientation. This adjustment is based on maximizing
the absolute values of the components in either the rows or columns of the \( U \) or \( V \)
matrices, respectively.
}
\details{
The function operates by first determining whether the adjustment should be based on
the \( U \) or \( V \) matrix. If `u_based_decision` is `TRUE`, the function will transpose \( U \)
and calculate the column with the maximum absolute value for each row in the transposed \( U \).
Then, it generates sign adjustments based on the signs of these maximal values. Both \( U \) and
\( V \) matrices are then adjusted by these signs. If `u_based_decision` is `FALSE`, a similar
process is applied but based on rows of \( V \) instead.
}
\examples{
# SVD decomposition of a matrix
A <- matrix(c(1, 2, 3, 2, -1, 4, 3, 6, -4), ncol = 3)
svd_A <- svd(A)
# Adjusting the signs of U and V
adjusted_svd <- svd_flip(svd_A$u, svd_A$v)
adjusted_u <- adjusted_svd[[1]]
adjusted_v <- adjusted_svd[[2]]

}
\seealso{
\code{\link[base]{svd}}
}
