% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/IncrementalDecomposition.R
\name{IncrementalDecomposition}
\alias{IncrementalDecomposition}
\title{Incremental Decomposition Class}
\description{
R6 class for performing and storing the results of an incremental
  principal component analysis (PCA) or other similar decompositions.
  Heavily influenced by (and sometimes and sometimes a port of)
  \href{https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.IncrementalPCA.html}{Scikit Learn's Incremental PCA implementation}
  @examples
  d = 20
  rho <- runif(d)
  sigma <- d:1
  df <- mvrnorm(100, rep(0, d), t(rho%*%diag(sigma))%*%t(rho))

  inc.pca <- IncrementalDecomposition$new(df[1:20,], 10)
  image(inc.pca$get_covariance(), ylim=c(1, 0))
  image(inc.pca$get_precision(), ylim=c(1, 0))

  inc.pca$partial_fit(df[21:50,], lambda = 0.98)
  image(inc.pca$get_precision(), ylim=c(1, 0))
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{n_components}}{Integer.
The number of principal components to retain in the model.}

\item{\code{components_}}{Matrix.
The matrix of principal components. Each column represents a principal component.}

\item{\code{noise_variance_}}{Numeric.
An estimate of the noise variance in the data.}

\item{\code{explained_variance_}}{Numeric vector.
The amount of variance explained by each of the principal components.}

\item{\code{n_samples_seen_}}{Integer.
The cumulative number of samples processed by the model.}

\item{\code{singular_values_}}{Numeric vector.
Singular values associated with each principal component.}

\item{\code{mean_}}{Numeric vector.
The mean of each feature in the dataset, computed incrementally.}

\item{\code{var_}}{Numeric vector.
The variance of each feature in the dataset, computed incrementally.}

\item{\code{explained_variance_ratio_}}{Numeric vector.
The proportion of the total variance explained by each principal component.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-IncrementalDecomposition-new}{\code{IncrementalDecomposition$new()}}
\item \href{#method-IncrementalDecomposition-partial_fit}{\code{IncrementalDecomposition$partial_fit()}}
\item \href{#method-IncrementalDecomposition-get_precision}{\code{IncrementalDecomposition$get_precision()}}
\item \href{#method-IncrementalDecomposition-get_covariance}{\code{IncrementalDecomposition$get_covariance()}}
\item \href{#method-IncrementalDecomposition-clone}{\code{IncrementalDecomposition$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-IncrementalDecomposition-new"></a>}}
\if{latex}{\out{\hypertarget{method-IncrementalDecomposition-new}{}}}
\subsection{Method \code{new()}}{
initialize Initialize the Incremental Decomposition object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{IncrementalDecomposition$new(X, n_components)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{A matrix or data frame of data from which to compute the decomposition.}

\item{\code{n_components}}{The number of components to compute.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This method initializes the decomposition object, sets the number of
  components, computes initial statistics from the data (mean and variance),
  and performs an initial update of the singular value decomposition (SVD) based on `X`.
  The fields such as mean, variance, number of samples seen are initialized.
  The method sets up the object state necessary for further incremental updates.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-IncrementalDecomposition-partial_fit"></a>}}
\if{latex}{\out{\hypertarget{method-IncrementalDecomposition-partial_fit}{}}}
\subsection{Method \code{partial_fit()}}{
Partially fit the model to new data
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{IncrementalDecomposition$partial_fit(X, lambda)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{A matrix or data frame of new data samples to integrate into the model.}

\item{\code{lambda}}{A scaling factor applied to the singular values during the update.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This method updates the decomposition model incrementally with new data. It
  recalculates the mean and variance incrementally and adjusts the data matrix before
  performing an SVD update. The method integrates the new data `X` into the existing model by:
  - Updating the cumulative statistics (mean and variance).
  - Adjusting the new data by removing the batch mean.
  - Applying a correction to adjust for the cumulative mean difference.
  - Scaling the existing components by `lambda` times the singular values.
  - Calling the internal function `update_svd` to perform the singular value decomposition on the adjusted data.
}

\subsection{Returns}{
None; updates the model's state in place.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-IncrementalDecomposition-get_precision"></a>}}
\if{latex}{\out{\hypertarget{method-IncrementalDecomposition-get_precision}{}}}
\subsection{Method \code{get_precision()}}{
Calculate the precision matrix of the model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{IncrementalDecomposition$get_precision()}\if{html}{\out{</div>}}
}

\subsection{Details}{
This method computes the precision matrix using the components and explained variance
  from the model. Adjustments are made for noise variance, and the method involves:
  - Subtracting the noise variance from the explained variance and zeroing negative results.
  - Calculating an initial precision matrix and then adjusting its diagonal based on the
    inverse of the adjusted explained variance.
  - Refining the precision matrix by solving and scaling operations, and adjusting the diagonal
    again to account for noise variance.
}

\subsection{Returns}{
A matrix representing the precision of the model.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-IncrementalDecomposition-get_covariance"></a>}}
\if{latex}{\out{\hypertarget{method-IncrementalDecomposition-get_covariance}{}}}
\subsection{Method \code{get_covariance()}}{
Calculate the covariance matrix of the model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{IncrementalDecomposition$get_covariance()}\if{html}{\out{</div>}}
}

\subsection{Details}{
This method computes the covariance matrix using the model's principal components
  and explained variance. It adjusts for noise variance by:
  - Subtracting the noise variance from the explained variance and setting negative results to zero.
  - Multiplying the principal components by the adjusted variance to compute the covariance.
  - Adding the noise variance to the diagonal of the covariance matrix to account for data noise.
}

\subsection{Returns}{
A matrix representing the covariance of the model.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-IncrementalDecomposition-clone"></a>}}
\if{latex}{\out{\hypertarget{method-IncrementalDecomposition-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{IncrementalDecomposition$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
